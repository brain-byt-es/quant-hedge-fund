"""
QS Connect - Zipline Bundle Builder

Creates Zipline-compatible data bundles from the DuckDB database.
"""

from pathlib import Path
from typing import Optional
from datetime import date
import os

import polars as pl
import pandas as pd
from loguru import logger

from qsconnect.database.duckdb_manager import DuckDBManager


class ZiplineBundler:
    """
    Builds Zipline-compatible data bundles.
    
    Zipline Reloaded requires data in a specific format for its
    event-based backtesting engine. This class handles the conversion
    from DuckDB to Zipline bundles.
    """
    
    def __init__(self, db_manager: DuckDBManager):
        """
        Initialize Zipline bundler.
        
        Args:
            db_manager: DuckDB manager instance
        """
        self._db_manager = db_manager
        self._bundle_dir = Path.home() / ".zipline" / "custom_bundles"
        self._bundle_dir.mkdir(parents=True, exist_ok=True)
        
        logger.info(f"Zipline bundler initialized. Bundle dir: {self._bundle_dir}")
    
    def build_bundle(
        self,
        bundle_name: str = "historical_prices_fmp",
        start_date: Optional[date] = None,
        end_date: Optional[date] = None,
    ) -> Path:
        """
        Build a Zipline bundle from database data.
        
        Args:
            bundle_name: Name for the bundle
            start_date: Start date for data inclusion
            end_date: End date for data inclusion
            
        Returns:
            Path to the created bundle directory
        """
        logger.info(f"Building Zipline bundle: {bundle_name}")
        
        # Get price data from database
        prices = self._db_manager.get_prices(
            start_date=start_date.isoformat() if start_date else None,
            end_date=end_date.isoformat() if end_date else None,
        )
        
        if prices.is_empty():
            logger.warning("No price data available for bundle")
            return Path()
        
        # Create bundle directory
        bundle_path = self._bundle_dir / bundle_name
        bundle_path.mkdir(parents=True, exist_ok=True)
        
        # Write price data in Zipline format
        self._write_daily_bundle(prices, bundle_path)
        
        # Write asset metadata
        self._write_asset_metadata(prices, bundle_path)
        
        logger.info(f"Bundle created: {bundle_path}")
        return bundle_path
    
    def _write_daily_bundle(self, prices: pl.DataFrame, bundle_path: Path) -> None:
        """Write daily price data in Zipline format."""
        # Convert to pandas for Zipline compatibility
        df = prices.to_pandas()
        
        # Ensure required columns
        required_cols = ["symbol", "date", "open", "high", "low", "close", "volume"]
        df = df[required_cols].copy()
        
        # Convert date to datetime
        df["date"] = pd.to_datetime(df["date"])
        
        # Save as parquet (Zipline reads these directly)
        output_path = bundle_path / "daily_prices.parquet"
        df.to_parquet(output_path)
        
        logger.info(f"Wrote {len(df)} price records to {output_path}")
    
    def _write_asset_metadata(self, prices: pl.DataFrame, bundle_path: Path) -> None:
        """Write asset metadata for Zipline."""
        symbols = prices["symbol"].unique().to_list()
        
        metadata = pd.DataFrame({
            "symbol": symbols,
            "asset_name": symbols,  # Can be enhanced with company names
            "start_date": prices.group_by("symbol").agg(pl.col("date").min())["date"].to_pandas(),
            "end_date": prices.group_by("symbol").agg(pl.col("date").max())["date"].to_pandas(),
            "exchange": "US",
        })
        
        output_path = bundle_path / "asset_metadata.parquet"
        metadata.to_parquet(output_path)
        
        logger.info(f"Wrote metadata for {len(symbols)} symbols")
    
    def register_bundle(self, bundle_name: str) -> None:
        """
        Register a bundle with Zipline.
        
        This creates the extension.py file needed by Zipline.
        """
        extension_path = Path.home() / ".zipline" / "extension.py"
        
        bundle_path = self._bundle_dir / bundle_name
        
        # Create or append to extension.py
        extension_code = f'''
# Auto-generated by QS Connect
from zipline.data.bundles import register
from zipline.data.bundles.csvdir import csvdir_equities

# Register {bundle_name} bundle
register(
    "{bundle_name}",
    csvdir_equities(
        ["daily"],
        str(r"{bundle_path}"),
    ),
    calendar_name="NYSE",
)
'''
        
        # Check if already registered
        if extension_path.exists():
            content = extension_path.read_text()
            if f'"{bundle_name}"' in content:
                logger.info(f"Bundle '{bundle_name}' already registered")
                return
            
            # Append to existing file
            with open(extension_path, "a") as f:
                f.write(extension_code)
        else:
            extension_path.write_text(extension_code)
        
        logger.info(f"Registered bundle: {bundle_name}")
    
    def ingest_bundle(self, bundle_name: str) -> None:
        """
        Ingest a bundle into Zipline.
        
        This runs the Zipline ingest command for the specified bundle.
        """
        import subprocess
        
        logger.info(f"Ingesting bundle: {bundle_name}")
        
        try:
            result = subprocess.run(
                ["zipline", "ingest", "-b", bundle_name],
                capture_output=True,
                text=True,
                check=True,
            )
            logger.info(f"Bundle ingested successfully: {result.stdout}")
        except subprocess.CalledProcessError as e:
            logger.error(f"Failed to ingest bundle: {e.stderr}")
            raise
    
    def list_bundles(self) -> list:
        """List available bundles."""
        bundles = [d.name for d in self._bundle_dir.iterdir() if d.is_dir()]
        return bundles
